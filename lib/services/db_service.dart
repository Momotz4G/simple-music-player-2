import 'package:isar/isar.dart';
import 'package:path_provider/path_provider.dart';
import 'dart:io';
import '../data/schemas.dart';

class DBService {
  // Singleton pattern
  static final DBService _instance = DBService._internal();
  factory DBService() => _instance;
  DBService._internal();

  // Single database instance
  static Isar? _db;
  Future<Isar> get db async {
    if (_db != null) return _db!;
    _db = await openDB();
    return _db!;
  }

  // 1. Initialize the Database - Only opens once
  Future<Isar> openDB() async {
    if (_db != null) return _db!;

    if (Isar.instanceNames.isEmpty) {
      final docDir = await getApplicationDocumentsDirectory();
      final dir = Directory('${docDir.path}/SimpleMusicDB');

      if (!await dir.exists()) {
        await dir.create(recursive: true);
      }

      _db = await Isar.open(
        [
          SongSchema,
          PlaylistSchema,
          HistoryEntrySchema,
          SavedStatSchema,
        ], // Register schemas here
        directory: dir.path,
        inspector: true, // Allows you to debug DB content while app runs!
      );
      return _db!;
    }
    _db = Isar.getInstance();
    return _db!;
  }

  // 2. Save Scanned Songs (The "Scanner" Logic)
  // This is smart: It updates existing songs instead of duplicating them.
  // 2. Save Scanned Songs (The "Scanner" Logic)
  // This is smart: It updates existing songs instead of duplicating them.
  Future<void> saveSongs(List<Song> newSongs) async {
    final isar = await db;

    // Using a Transaction (Txn) ensures all data is saved safely at once.
    await isar.writeTxn(() async {
      for (final newSong in newSongs) {
        // Check if this path already exists
        final existingSong =
            await isar.songs.filter().pathEqualTo(newSong.path).findFirst();

        if (existingSong != null) {
          // UPDATE: Keep ID, update fields
          existingSong.title = newSong.title;
          existingSong.artist = newSong.artist;
          existingSong.album = newSong.album;
          existingSong.duration = newSong.duration;
          // Don't overwrite playCount or dateAdded if we don't want to
          // existingSong.dateAdded = newSong.dateAdded;

          await isar.songs.put(existingSong);
        } else {
          // INSERT: New song
          await isar.songs.put(newSong);
        }
      }
    });
  }

  // 3. Fetch All Songs (For Library Page)
  Future<List<Song>> getAllSongs() async {
    final isar = await db;
    // 'sortByName()' is automatically generated by Isar if you index the name,
    // otherwise we can just use default sorting.
    return await isar.songs.where().findAll();
  }

  // 4. Update Stats (For "History" and "Most Played")
  Future<void> updateSongPlayCount(int songId) async {
    final isar = await db;

    await isar.writeTxn(() async {
      final song = await isar.songs.get(songId);
      if (song != null) {
        song.playCount += 1;
        song.lastPlayed = DateTime.now();
        await isar.songs.put(song);

        // Cloud tracking moved to StatsProvider
      }
    });
  }

  // New helper for PlayerProvider (which uses SongModel, not Isar Song)
  Future<void> updateSongPlayCountByPath(String filePath) async {
    final isar = await db;
    await isar.writeTxn(() async {
      // Find the song by path
      final song = await isar.songs.filter().pathEqualTo(filePath).findFirst();

      if (song != null) {
        song.playCount += 1;
        song.lastPlayed = DateTime.now();
        await isar.songs.put(song);

        // Cloud tracking moved to StatsProvider
      } else {
        // print("⚠️ Warning: Could not find song in DB to update play count: $filePath");
      }
    });
  }

  // 5. Get Top 10 Most Played (For Stats Page)
  Future<List<Song>> getMostPlayed() async {
    final isar = await db;
    // This query is incredibly fast compared to sorting a List in Dart
    return await isar.songs.where().sortByPlayCountDesc().limit(10).findAll();
  }

  // 6. Clean Database (Optional: Remove songs that no longer exist on disk)
  Future<void> cleanMissingSongs(List<String> existingPaths) async {
    final isar = await db;
    await isar.writeTxn(() async {
      // Advanced: Find songs in DB whose path is NOT in the existingPaths list
      // and delete them. (We can implement this logic later if needed)
    });
  }

  // 7. Get Total Plays (Across all songs)
  Future<int> getTotalPlays() async {
    final isar = await db;
    // Using property sum is efficient
    return await isar.songs.where().playCountProperty().sum();
  }

  // Get Total Plays from STATS (History of all plays, even streamed)
  Future<int> getTotalStatsPlays() async {
    final isar = await db;
    return await isar.savedStats.where().playCountProperty().sum();
  }
}
